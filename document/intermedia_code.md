# LRC中间代码格式

## 相关文件

*   在debug模式下运行lrc的时候，生成的文件中的`.ic`后缀的文件是存储中间代码序列的，`.fg`后缀的文件是存储构造成了流图的中间代码序列的

## 基本格式

*   LRC中使用**四元式**作为中间代码，即一条中间代码由下面四个部分组成：
    *   操作码op
    *   第一个操作数arg1
    *   第二个操作数arg2
    *   结果result

## 输出格式（输出到`.ic`和`.fg`文件中）

*   当操作数是变量的时候，在输出的时候会将它的作用域和名字一起输出，例如：

    ```c
    int a;
    int main()
    {
      int a;
     	if(1){
        int a;
        while(1)
        {
          int a;
        }
        {
          int a;
        }
      }
      else{
        int a;
      }
    	if(1){
        int a;
      }
    }
    ```

    上述代码定义了多个名为a的变量，但是他们的作用域是不冲突的，因此上述代码是合法的。而将其翻译成中间代码之后，为了区分重名变量，需要使用作用域进行区分：

    *   第1行定义的a在中间代码中输出为

        ```c
        a
        ```

        因为它是全局变量，只需输出名字即可

    *   第4行定义的a在中间代码中输出为

        ```c
        main::a
        ```

        表示这个a是在main函数下定义的

    *   第6行定义的a在中间代码中输出为

        ```c
        main::if_0::a
        ```

        表示这个a是在main函数下的首个if块中定义的

    *   第9行定义的a在中间代码中输出为

        ```c
        main::if_0::while_0::a
        ```

        表示这个a是在main函数下的首个if块中的首个while块中定义的

    *   第12行定义的a在中间代码中输出为

        ```c
        main::if_0::_0::a
        ```

        表示这个a是在main函数下的首个if块中的首个匿名语句块中定义的

    *   第16行定义的a在中间代码中输出为

        ```c
        main::else_0::a
        ```

        表示这个a是在main函数下的首个else块中定义的

    *   第19行定义的a在中间代码中输出为

        ```c
        main::if_1::a
        ```

        表示这个a是在main函数下的第二个if块中定义的

*   当操作数是数组变量取元素的时候，不管数组定义的时候的维度是几维，也不管取元素的时候取了几维，一律降为一维。例如：

    ```c
    int arr[3][5][2];
    arr[1][2][1]=3;
    ```

    会被翻译成

    ```c
    ASSIGN 3-->arr[15]
    ```

*   当操作数是数组取元素的时候，有可能会出现数组取元素仍旧是数组的情况，那么它的输出和上面的是一样的。例如：

    ```c
    int arr[3][5][2];
    getarray(arr[1][2]);
    ```

    会被翻译成

    ```c
    CALL getarray(arr[14])
    ```

    也就意味着arr\[1\]\[2\]和arr\[1\]\[2\]\[0\]都是输出成arr[14]，但是在代码中可以把两者区分出来，一个是数组，一个是普通的数组取元素，因此不必担心

*   当操作数是临时变量的时候，每一个临时变量都有一个编号（全局的），那么在输出临时变量的时候就是在该编号前面加上`@`即可。例如：

    ```c
    @1
    ```

    临时变量输出的时候不需要指明作用域，因为临时变量的生命周期不会超过一个基本块，而且一个临时变量只能被赋值一次，所以没有重名的可能

*   当操作数是标签的时候，每一个标签都有一个编号（全局的），那么在输出该标签的时候就是在该编号前面加上`.`即可。例如：

    ```c
    .1
    ```

*   对于赋值，运算，逻辑判断，跳转，函数调用这类代码，都是先输出op，再输出arg1，arg2和result，其中result在`-->`的箭头指向的方向，arg1和arg2则在另一头。例如：

    ```c
    SUB		main::i , 1 --> (int)@9
    ```

    和

    ```c
    CALL		getarray ( image_in )  --> (int)@2
    ```

*   对于变量定义VAR_DEFINE，会先输出该变量的数据类型，再输出其变量名（由名字和作用域组成），如果是数组变量的话，再输出其数组长度和维度，并且查看是否需要输出初始值（全是0）。例如：

    ```c
    int main::i
    ```

    和

    ```c
    int image_in[524288]={0,...}
    ```

*   对于函数定义FUNC_DEFINE，先输出返回值类型，再输出函数名，最后输出函数形参。例如：

    ```c
    int cutout ( int cutout::val )  : 
    ```

*   对于RET来说，直接在RET后面加上要返回的变量即可：

    ```c
    RET		cutout::val
    ```

*   对于NOP，END_FUNC_DEFINE来说，是没有输出的

## 注意事项

*   中间代码中只有ASSIGN可以进行类型转换，其他的代码都是不行的。例如：

    ```c
    int a,c;
    float b;
    c=a+b;
    ```

    不翻译成：

    ```
    ADD a,b-->c
    ```

    而是翻译成

    ```c
    ASSIGN b-->(float)@1
    ADD a,@1-->c
    ```

*   中间变量的生命周期不能超过一个基本块
*   一个中间变量只能被赋值一次，不能被多次赋值

## 各类中间代码

### NOP

*   空的中间代码，什么也不做

### ASSIGN

*   把arg1的值赋值给result，忽略arg2
*   可以把一个float类型的变量赋值给一个int类型的变量，也可以把银行i个int类型的变量赋值给一个float类型的变量，用于类型转换

### ADD，SUB，MUL，DIV，MOD，AND，OR，XOR

*   对arg1和arg2进行相应的运算，结果赋值给result
*   要求arg1，arg2，result的数据类型必须一致，其中MOD要求三者都是int

### NOT

*   对arg1进行逻辑取反（即非0的变成0，0变成非0），结果赋值给result，忽略arg2

### EQ，UEQ，GT，LT，GE，LE

*   对arg1和arg2进行相应的逻辑判断，结果赋值给result，true就是1，false就是0
*   要求arg1，arg2的数据类型必须一致，并且要求result一定是int类型的

### JMP

*   无条件跳转，忽略arg1和arg2，要求result是一个标签（label）。表示无条件跳转到该标签处

### IF_JMP，IF_NOT_JMP

*   条件跳转，要求arg1是一个数据（ic_data），result是一个标签（label）。IF_JMP表示如果arg1是true，就跳转，否则不跳转；而IF_NOT_JMP的含义正好相反

*   要求arg1必须是逻辑判断的结果。例如：

    ```c
    int a;
    if(a)
    {
      ......
    }
    ```

    不会翻译成

    ```c
    		IF_NOT_JMP a-->.1
    		......
     .1:
    ```

    而是翻译成

    ```c
    		EQ a,0-->(int)@1
    		IF_NOT_JMP @1-->.1
    		......
     .1:
    ```

### VAR_DEFINE

*   变量定义，result是要定义的变量，可以是普通变量，也可以是数组变量，忽略arg1和arg2
*   只允许数组变量在定义的时候进行初始化，而且只允许将所有的数组元素全部初始化为0

### LABEL_DEFINE

*   标签定义，result是要定义的标签，忽略arg1和arg2

### FUNC_DEFINE

*   函数定义，arg1是若干个变量，表示函数的形参列表，result是要定义的函数，忽略arg2

### END_FUNC_DEFINE

*   结束函数定义，result是对应的函数，忽略arg1和arg2
*   一个FUNC_DEFINE对应一个END_FUNC_DEFINE，不管这个函数有多少个return

### CALL

*   函数调用，arg1是被调用的函数，arg2是若干个变量，表示调用函数的时候的实参列表，result是接受函数调用返回值的变量
*   要求在调用函数的时候，实参和形参的数据类型必须一致，如果不一致会先使用ASSIGN进行类型转换
*   也要求函数的返回值和接受函数返回值的变量类型一致，如果不一致需要事后使用ASSIGN进行类型转换

### RET

*   函数返回，result表示要返回的操作数，忽略arg1和arg2
*   要求返回的数据类型必须和函数定义的时候的返回值类型一致，如果不一致需要使用ASSIGN先进行转换



